const dav = require('dav');
import WyCalendarStore from '../../../../../../src/flux/stores/wycalendar-store.es6';
import ICAL from 'ical.js';
import * as IcalStringBuilder from '../common-utils/icalStringBuilder';
import moment from 'moment-timezone';
import * as PARSER from '../common-utils/Parser';

export const deleteCaldavSingle = async payload => {
  const { data, user } = payload;
  const debug = true;

  // Try catch for HTTP errors, offline etc.
  try {
    let result;

    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag,
    };

    // For recurring events, we want to just add it to ex dates instead
    // Due to caldav nature, deleting an etag instead of updating causes deletion of
    // entire series.
    // Updating is done by pushing the entire iCal string to the server
    if (data.isRecurring) {
      // Get recurring pattern to build new iCal string for updating
      const [recurrencePattern] = WyCalendarStore.getIcloudRpLists().filter(
        rp => data.iCalUID === rp.iCalUID
      );
      if (recurrencePattern === undefined) {
        console.log('error');
        return;
      }
      const jsonRecurr = ICAL.Recur._stringToData(recurrencePattern.iCALString);
      // debugger;
      const { freq } = jsonRecurr;
      if (freq === 'MONTHLY') {
        // If there is a setpos, I need ot merge them up into one param
        // RRule gen splits them into bysetpos and byday, but server takes in byday
        // E.g. bysetpos = 1, byday = TU, merge to byday = 1TU
        // If there is no setpos, it means it is a by month day event
        if (jsonRecurr.BYSETPOS !== undefined) {
          jsonRecurr.BYDAY = jsonRecurr.BYSETPOS + jsonRecurr.BYDAY;
          delete jsonRecurr.BYSETPOS;
        } else if (Array.isArray(jsonRecurr.BYDAY)) {
          jsonRecurr.BYDAY = jsonRecurr.BYDAY.join(',');
        }
      }
      // Builds the iCal string
      const iCalString = IcalStringBuilder.buildICALStringDeleteRecurEvent(
        recurrencePattern,
        data,
        jsonRecurr
      );
      if (debug) {
        console.log(iCalString);
      }

      // To delete a single recurring pattern, the calendar object is different.
      // So we add the string into the object we are PUT-ing to the server
      const calendarData = iCalString;
      const calendarObject = {
        url: caldavUrl,
        calendarData,
      };
      // Result will throw error, we can do a seperate check here if needed.
      result = await dav.updateCalendarObject(calendarObject, option);
    } else {
      // As we are deleting a single object, non recurring event
      // It is identified by etag. So for our calendar object,
      // We just need to know the endpoint, which is the caldavUrl
      const calendarObject = {
        url: caldavUrl,
      };
      // Result will throw error, we can do a seperate check here if needed.
      result = await dav.deleteCalendarObject(calendarObject, option);
    }
    if (debug) {
      console.log('delete single calendar object results', result);
    }
  } catch (caldavError) {
    console.log('Handle Caldav pending action here', caldavError);
  }
};
export const deleteCaldavAll = async payload => {
  const { data, user } = payload;
  const debug = false;

  try {
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag,
    };

    // To delete the entire series, find a event with an etag, and run delete on it.
    // Do not need calendar as etag is the only identifier you need.
    const calendarObject = {
      url: caldavUrl,
    };
    // Result will throw error, we can do a seperate check here if needed.
    const result = await dav.deleteCalendarObject(calendarObject, option);
    if (debug) {
      console.log(result);
    }
  } catch (caldavError) {
    console.log('Handle Caldav pending action here', caldavError);
  }
};
export const deleteCaldavFuture = async payload => {
  console.log('payload', payload);
  const { data, user } = payload;
  const debug = true;

  try {
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    // UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag,
    };

    // For recurring events, we want to ensure exdates is clean too.
    // Clean means no duplicate, and has the right values.
    // This ensures that if we re-expand the series, the exdates are not copied over
    // It is starting to look like CalDav is just a storage service, as there can be duplicates.
    // Due to caldav nature, we can just update the end condition accordingly.
    // As we are deleting this and future events, we just need to update the end condition.
    // Updating is done by pushing the entire iCal string to the server
    // Get recurring pattern to build new iCal string for updating
    const [recurrencePattern] = WyCalendarStore.getIcloudRpLists().filter(
      rp => data.iCalUID === rp.iCalUID
    );
    if (recurrencePattern === undefined) {
      console.log('error');
      return;
    }
    if (debug) {
      console.log('recurrencepattern', recurrencePattern);
    }

    // Problem here is that updating the rp based on the exDates and recurringIds.
    // This means we need to remove it from the rp and build the rp based on them.
    // Note that we cannot edit the RxDoc directly, therefore, we use the JsonObject
    // We set the exDates according to if it is before the selected start time.
    // Compared using moment.
    recurrencePattern.exDates = recurrencePattern.exDates
      .split(',')
      .filter(date =>
        moment
          .tz(date * 1000, data.start.timezone)
          .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone), 'day')
      )
      .join(',');

    // Do the same for edited ids.
    recurrencePattern.recurrenceIds = recurrencePattern.recurrenceIds
      .split(',')
      .filter(date =>
        moment
          .tz(date * 1000, data.start.timezone)
          .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone), 'day')
      )
      .join(',');

    const ruleSet = PARSER.buildRuleSet(
      recurrencePattern,
      recurrencePattern.recurringTypeId,
      data.start.timezone
    );
    const recurDates = ruleSet.all().map(date => date.toJSON());
    const recurAfterDates = recurDates.filter(date =>
      moment(date).isSameOrAfter(moment.tz(data.start.dateTime * 1000, data.start.timezone))
    );
    let deleteWholeSeries = false;
    // To settle the end condition
    if (recurrencePattern.numberOfRepeats > 0) {
      recurrencePattern.numberOfRepeats -= recurAfterDates.length;
      if (recurrencePattern.numberOfRepeats <= 0) {
        deleteWholeSeries = true;
      }
    } else if (recurrencePattern.until !== '') {
      // Need to test until end date, coz date time is ical type.
      const momentSelectedDt = moment
        .tz(data.start.dateTime * 1000, data.start.timezone)
        .add(-1, 'second');
      const momentPreviousDt = moment.tz(
        recurrencePattern.recurringTypeId * 1000,
        data.start.timezone
      );
      // recurrencePattern.until = momentSelectedDt.format('YYYY-MM-DDThh:mm:ss');
      recurrencePattern.until = momentSelectedDt.unix();
      if (momentSelectedDt.isSame(momentPreviousDt, 'day')) {
        deleteWholeSeries = true;
      }
    } else {
      // Yet to figure out how to deal with no end date.
    }

    if (deleteWholeSeries) {
      const calendarObject = {
        url: caldavUrl,
      };
      // Result will throw error, we can do a seperate check here if needed.
      await dav.deleteCalendarObject(calendarObject, option);
    } else {
      // Builds the iCal string
      const iCalString = IcalStringBuilder.buildICALStringDeleteRecurEvent(
        recurrencePattern,
        data,
        undefined
      );

      // To delete a single recurring pattern, the calendar object is different.
      // So we add the string into the object we are PUT-ing to the server

      // NOTE: updateIcalString function is a temporary hotfix as ICAL library
      //   doesn't include the UTC 'Z' timezone in the RRule, causing datetime mismatch when fetching
      const calendarData = updateIcalString(iCalString);
      const calendarObject = {
        url: caldavUrl,
        calendarData,
      };
      console.log(iCalString);
      console.log(calendarData);
      // Result will throw error, we can do a seperate check here if needed.
      const result = await dav.updateCalendarObject(calendarObject, option);
    }
  } catch (caldavError) {
    console.log('Handle Caldav pending action here', caldavError);
  }
};

// append a Z at the end of the RRule, might have better way to do this
const updateIcalString = iCalString => {
  let originalUNTILrrule = iCalString.match(
    /UNTIL=\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\d|3[0-1])T([0-1]\d|2[0-3])[0-5]\d[0-5]\dZ?/g
  );
  // second expression short circuits if res isn't null
  if (originalUNTILrrule === null || originalUNTILrrule[[originalUNTILrrule.length - 1] === 'Z']) {
    return iCalString;
  } else if (originalUNTILrrule[originalUNTILrrule.length - 1] !== 'Z') {
    let updatedUNTILrrule = originalUNTILrrule + 'Z';
    let updatedICalString = iCalString.replace(originalUNTILrrule, updatedUNTILrrule);
    return updatedICalString;
  }
  return iCalString;
};
