const dav = require('dav');
import { Actions, CalendarPluginStore } from 'mailspring-exports';
import ICAL from 'ical.js';
import * as IcalStringBuilder from '../common-utils/ical-string-builder';
import moment from 'moment-timezone';
import * as PARSER from '../common-utils/parser';
import {
  DELETE_ALL_RECURRING_EVENTS,
  DELETE_EDITED_EVENT,
  DELETE_FUTURE_RECCURRING_EVENTS,
  DELETE_NON_EDITED_EVENT,
  DELETE_SINGLE_EVENT,
  ICLOUD_ACCOUNT,
  UPDATE_ICALSTRING,
} from '../constants';

export const deleteCaldavSingle = async payload => {
  const { data, user } = payload;

  // Needed information for deleting of Caldav information.
  // etag - Event tag, there is the same for calendar if needed.
  //   UUID generated by caldav servers
  // caldavUrl - URL of specific endpoint for deleting single or recurrring events
  const { etag, caldavUrl } = data;

  // Parse user information from account layer to dav object.
  const xhrObject = new dav.transport.Basic(
    new dav.Credentials({
      username: user.username,
      password: user.password,
    })
  );
  // Ensure etag is set in option for no 412 http error.
  const option = {
    xhr: xhrObject,
    etag,
  };

  // For recurring events, we want to just add it to ex dates instead
  // Due to caldav nature, deleting an etag instead of updating causes deletion of
  // entire series.
  // Updating is done by pushing the entire iCal string to the server
  if (data.isRecurring) {
    try {
      // Get recurring pattern to build new iCal string for updating
      const [recurrencePattern] = CalendarPluginStore.getRpLists(ICLOUD_ACCOUNT).filter(
        rp => data.iCalUID === rp.iCalUID
      );

      const jsonRecurr = ICAL.Recur._stringToData(recurrencePattern.iCALString);
      // debugger;
      const { freq } = jsonRecurr;
      if (freq === 'MONTHLY') {
        // If there is a setpos, I need ot merge them up into one param
        // RRule gen splits them into bysetpos and byday, but server takes in byday
        // E.g. bysetpos = 1, byday = TU, merge to byday = 1TU
        // If there is no setpos, it means it is a by month day event
        if (jsonRecurr.BYSETPOS !== undefined) {
          jsonRecurr.BYDAY = jsonRecurr.BYSETPOS + jsonRecurr.BYDAY;
          delete jsonRecurr.BYSETPOS;
        } else if (Array.isArray(jsonRecurr.BYDAY)) {
          jsonRecurr.BYDAY = jsonRecurr.BYDAY.join(',');
        }
      }
      let [iCalString, exdateToDelete] = IcalStringBuilder.buildICALStringDeleteRecurEvent(
        recurrencePattern,
        data,
        jsonRecurr
      );

      // To delete a single recurring pattern, the calendar object is different.
      // So we add the string into the object we are PUT-ing to the server
      const calendarData = iCalString;
      const calendarObject = {
        url: caldavUrl,
        calendarData,
      };
      // Result will throw error, we can do a seperate check here if needed.
      await dav.updateCalendarObject(calendarObject, option);
      if (exdateToDelete !== undefined) {
        iCalString = IcalStringBuilder.buildICALStringDeleteEditedSingleEvent(
          exdateToDelete,
          iCalString
        );
        const updatedCalendarObject = {
          url: caldavUrl,
          calendarData: iCalString,
        };
        await dav.updateCalendarObject(updatedCalendarObject, option);
      }
      // Delete event from reflux store
      Actions.deleteCalendarData(ICLOUD_ACCOUNT, data.id, DELETE_SINGLE_EVENT);
      // Update them all to the new iCalString.
      const toBeEditedIcalstring = { iCALString: iCalString };
      Actions.updateCalendarData(ICLOUD_ACCOUNT, data.iCalUID, toBeEditedIcalstring, UPDATE_ICALSTRING);
    } catch (error) {
      console.log('error deleting single event from recurring series', error);
    }
  } else {
    // As we are deleting a single object, non recurring event
    // It is identified by etag. So for our calendar object,
    // We just need to know the endpoint, which is the caldavUrl
    try {
      const calendarObject = {
        url: caldavUrl,
      };
      // Result will throw error, we can do a seperate check here if needed.
      await dav.deleteCalendarObject(calendarObject, option);
      // Delete event from reflux store
      Actions.deleteCalendarData(ICLOUD_ACCOUNT, data.id, DELETE_SINGLE_EVENT);
    } catch (error) {
      console.log('error deleting single event from non recurring', error);
    }
  }
};
export const deleteCaldavAll = async payload => {
  const { data, user } = payload;

  // Needed information for deleting of Caldav information.
  // etag - Event tag, there is the same for calendar if needed.
  //   UUID generated by caldav servers
  // caldavUrl - URL of specific endpoint for deleting single or recurrring events
  const { etag, caldavUrl } = data;

  // Parse user information from account layer to dav object.
  const xhrObject = new dav.transport.Basic(
    new dav.Credentials({
      username: user.username,
      password: user.password,
    })
  );
  // Ensure etag is set in option for no 412 http error.
  const option = {
    xhr: xhrObject,
    etag,
  };

  // To delete the entire series, find a event with an etag, and run delete on it.
  // Do not need calendar as etag is the only identifier you need.
  try {
    const calendarObject = {
      url: caldavUrl,
    };
    // Result will throw error, we can do a seperate check here if needed.
    await dav.deleteCalendarObject(calendarObject, option);
    Actions.deleteCalendarData(ICLOUD_ACCOUNT, data.recurringEventId, DELETE_ALL_RECURRING_EVENTS);
  } catch (error) {
    console.log('error deleting all events from recurring series', error);
  }
};
export const deleteCaldavFuture = async payload => {
  const { data, user } = payload;

  // Needed information for deleting of Caldav information.
  // etag - Event tag, there is the same for calendar if needed.
  // UUID generated by caldav servers
  // caldavUrl - URL of specific endpoint for deleting single or recurrring events
  const { etag, caldavUrl } = data;

  // Parse user information from account layer to dav object.
  const xhrObject = new dav.transport.Basic(
    new dav.Credentials({
      username: user.username,
      password: user.password,
    })
  );
  // Ensure etag is set in option for no 412 http error.
  const option = {
    xhr: xhrObject,
    etag,
  };

  // For recurring events, we want to ensure exdates is clean too.
  // Clean means no duplicate, and has the right values.
  // This ensures that if we re-expand the series, the exdates are not copied over
  // It is starting to look like CalDav is just a storage service, as there can be duplicates.
  // Due to caldav nature, we can just update the end condition accordingly.
  // As we are deleting this and future events, we just need to update the end condition.
  // Updating is done by pushing the entire iCal string to the server
  // Get recurring pattern to build new iCal string for updating
  const [recurrencePattern] = CalendarPluginStore.getRpLists(ICLOUD_ACCOUNT).filter(
    rp => data.iCalUID === rp.iCalUID
  );
  if (recurrencePattern === undefined) {
    console.log('error');
    return;
  }

  // **LEGACY CODE** not sure why this is needed - March 2021 **
  // Problem here is that updating the rp based on the exDates and recurringIds.
  // This means we need to remove it from the rp and build the rp based on them.
  // Note that we cannot edit the RxDoc directly, therefore, we use the JsonObject
  // We set the exDates according to if it is before the selected start time.
  // Compared using moment.
  recurrencePattern.exDates = recurrencePattern.exDates
    .split(',')
    .filter(date =>
      moment
        .tz(date * 1000, data.start.timezone)
        .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone), 'day')
    )
    .join(',');

  // Do the same for edited ids.
  recurrencePattern.recurrenceIds = recurrencePattern.recurrenceIds
    .split(',')
    .filter(date =>
      moment
        .tz(date * 1000, data.start.timezone)
        .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone), 'day')
    )
    .join(',');

  const ruleSet = PARSER.buildRuleSet(
    recurrencePattern,
    recurrencePattern.recurringTypeId,
    data.start.timezone
  );
  const recurDates = ruleSet.all().map(date => date.toJSON());
  const recurAfterDates = recurDates.filter(date =>
    moment(date).isSameOrAfter(moment.tz(data.start.dateTime * 1000, data.start.timezone))
  );
  let deleteWholeSeries = false;
  // To settle the end condition
  if (recurrencePattern.numberOfRepeats > 0) {
    recurrencePattern.numberOfRepeats -= recurAfterDates.length;
    if (recurrencePattern.numberOfRepeats <= 0) {
      deleteWholeSeries = true;
    }
  } else if (recurrencePattern.until !== '') {
    // Need to test until end date, coz date time is ical type.
    const momentSelectedDt = moment
      .tz(data.start.dateTime * 1000, data.start.timezone)
      .add(-1, 'second');
    const momentPreviousDt = moment.tz(
      recurrencePattern.recurringTypeId * 1000,
      data.start.timezone
    );
    // recurrencePattern.until = momentSelectedDt.format('YYYY-MM-DDThh:mm:ss');
    recurrencePattern.until = momentSelectedDt.unix();
    if (momentSelectedDt.isSame(momentPreviousDt, 'day')) {
      deleteWholeSeries = true;
    }
  } else {
    // Yet to figure out how to deal with no end date.
  }

  if (deleteWholeSeries) {
    try {
      const calendarObject = {
        url: caldavUrl,
      };
      // Result will throw error, we can do a seperate check here if needed.
      await dav.deleteCalendarObject(calendarObject, option);
      Actions.deleteCalendarData(
        ICLOUD_ACCOUNT,
        data.iCalUID,
        DELETE_FUTURE_RECCURRING_EVENTS,
        data.start.dateTime
      );
    } catch (error) {
      console.log('error deleting all events via future recurrences', error);
    }
  } else {
    try {
      // Builds the iCal string
      const [iCalString] = IcalStringBuilder.buildICALStringDeleteRecurEvent(
        recurrencePattern,
        data,
        undefined
      );

      // To delete a single recurring pattern, the calendar object is different.
      // So we add the string into the object we are PUT-ing to the server
      const calendarData = iCalString;
      const calendarObject = {
        url: caldavUrl,
        calendarData,
      };
      // Result will throw error, we can do a seperate check here if needed.
      await dav.updateCalendarObject(calendarObject, option);
      Actions.deleteCalendarData(
        ICLOUD_ACCOUNT,
        data.iCalUID,
        DELETE_FUTURE_RECCURRING_EVENTS,
        data.start.dateTime
      );
      // Update them all to the new iCalString.
      const toBeEditedIcalstring = { iCALString: iCalString };
      Actions.updateCalendarData(ICLOUD_ACCOUNT, data.iCalUID, toBeEditedIcalstring, UPDATE_ICALSTRING);
    } catch (error) {
      console.log('error deleting future recurrences', error);
    }
  }
};
