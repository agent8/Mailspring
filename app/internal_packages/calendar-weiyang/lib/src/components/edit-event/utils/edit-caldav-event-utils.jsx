import ICAL from 'ical.js';
import uuidv4 from 'uuid';
import moment from 'moment-timezone';
import * as IcalStringBuilder from '../../common-utils/ical-string-builder';
import * as PARSER from '../../common-utils/parser';
import { Actions, CalendarPluginStore } from 'mailspring-exports';
import {
  DELETE_ALL_RECURRING_EVENTS,
  DELETE_NON_MASTER_EVENTS,
  GET_ALL_EVENT,
  GET_MASTER_EVENT,
  UPDATE_ICALSTRING,
  UPDATE_MASTER_EVENT,
  UPDATE_RECURRENCE_PATTERN,
  UPDATE_SINGLE_EVENT,
  UPSERT_RECURRENCE_PATTERN,
} from '../../constants';
const dav = require('dav');

export const editCalDavSingle = async payload => {
  console.log('entered editcaldavsingle');
  const debug = false;
  try {
    let iCalString;

    // #region Getting information
    // Get Information from flux store
    const [data] = CalendarPluginStore.getIcloudCalendarData().filter(
      event => event.id === payload.id
    );
    // no event found
    if (data === undefined) {
      console.log('error');
      return;
    }
    const { user } = payload;
    // #endregion

    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
    };
    // #endregion

    // #region Updating of Single event, based on Recurring or not
    if (payload.isRecurring) {
      const [recurrencePattern] = CalendarPluginStore.getIcloudRpLists().filter(
        rp => data.iCalUID === rp.iCalUID
      );
      if (recurrencePattern === undefined) {
        console.log('error');
        return;
      }
      // Builds the iCal string
      iCalString = IcalStringBuilder.buildICALStringUpdateRecurEvent(
        recurrencePattern,
        data,
        payload
      );

      // Due to how there is no master,
      // We need to ensure all events that are part of the series
      // have the same iCal string such that we do not have inconsistency.
      // Update them all to the new iCalString.
      const toBeEditedIcalstring = { iCALString: iCalString };
      Actions.updateIcloudCalendarData(data.iCalUID, toBeEditedIcalstring, UPDATE_ICALSTRING);
    } else if (!payload.isRecurring && payload.updatedIsRecurring) {
      // if event is originally single and is going to become recurring
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleEvent(
        payload,
        data,
        payload.updatedRrule
      );
    } else {
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleEvent(payload, data);
    }
    // #endregion

    // #region Updating Calendar, Local Side
    // single -> recurring event
    if (!payload.isRecurring && payload.updatedIsRecurring) {
      const masterEvent = data; // data = event object retrieved from db
      masterEvent.isRecurring = 1;
      masterEvent.isMaster = 1;
      masterEvent.iCALString = iCalString;
      const rruleObj = ICAL.Recur._stringToData(payload.updatedRrule);
      let untilJson;
      if (rruleObj.until !== undefined) {
        untilJson = rruleObj.until.toJSON();
        untilJson.month -= 1; // Month needs to minus one due to start date
      }
      const recurrencePattern = PARSER.parseRecurrenceEvents([
        {
          eventData: masterEvent,
          recurData: {
            rrule: {
              stringFormat: payload.updatedRrule,
              freq: rruleObj.freq,
              interval: rruleObj.interval !== undefined ? rruleObj.interval : 1,
              until: untilJson,
              count: rruleObj.count,
            },
            exDates: [],
            recurrenceIds: [],
            modifiedThenDeleted: false,
            iCALString: payload.updatedRrule,
          },
        },
      ]);
      const expandedRecurEvents = PARSER.parseRecurrence(recurrencePattern[0], masterEvent);
      CalendarPluginStore.updateIcloudRpLists(recurrencePattern[0], UPSERT_RECURRENCE_PATTERN);

      // add expanded events into reflux
      Actions.addIcloudCalendarData(expandedRecurEvents);
    }
    // #endregion

    // #region Updating Calendar, Server Side
    // To delete a single recurring pattern, the calendar object is different.
    // So we add the string into the object we are PUT-ing to the server
    const calendarObject = {
      url: caldavUrl,
      calendarData: iCalString,
    };
    // Result will throw error, we can do a seperate check here if needed.
    await dav.updateCalendarObject(calendarObject, option);
    // #endregion
  } catch (error) {
    console.log('(editCalDavSingle) Error', error, payload.id);
  }
};

export const editCalDavAllRecurrenceEvents = async payload => {
  const debug = false;
  try {
    // #region Getting information
    // Get Information from flux store
    const [data] = CalendarPluginStore.getIcloudCalendarData().filter(
      event => event.id === payload.id
    );
    // no event found
    if (data === undefined) {
      console.log('error');
      return;
    }
    const { user } = payload;
    // #endregion

    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl, calendarId } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag,
    };
    // #endregion

    // #region Generation of new iCalString & DB updating
    // For recurring events, we want to just add it to ex dates instead
    // Due to caldav nature, deleting an etag instead of updating results in deleting of
    // entire series.
    // Updating is done by pushing the entire iCal string to the server
    let iCalString = '';
    // recur -> single
    if (!payload.updatedIsRecurring) {
      // delete recurrencePattern
      CalendarPluginStore.deleteIcloudRpLists(data.iCalUID);
      // retrieve master
      const [masterEvent] = CalendarPluginStore.getIcloudCalendarData().filter(
        event => event.isMaster && event.recurringEventId === data.recurringEventId
      );
      // delete non-master
      Actions.deleteIcloudCalendarData(data.recurringEventId, DELETE_NON_MASTER_EVENTS);
      // update iCal string
      iCalString = IcalStringBuilder.editICALStringRecurringToSingle(payload, masterEvent);

      // update db
      const toBeEditedData = {
        summary: payload.title,
        description: payload.description,
        allDay: payload.allDay,
        start: { dateTime: payload.start.unix(), timezone: payload.start.tz() },
        end: { dateTime: payload.end.unix(), timezone: payload.end.tz() },
        location: payload.location,
        organizer: payload.organizer,
        attendee: payload.attendees,
        recurringEventId: null,
        isRecurring: false,
        isMaster: null,
        iCALString: iCalString,
      };
      Actions.updateIcloudCalendarData(masterEvent.id, toBeEditedData, UPDATE_MASTER_EVENT);
    } else {
      // Get recurring pattern to build new iCal string for updating
      const [recurrencePattern] = CalendarPluginStore.getIcloudRpLists().filter(
        rp => rp.originalId === data.iCalUID
      );
      const jsonRecurr = ICAL.Recur._stringToData(payload.rrule);
      if (jsonRecurr.until !== undefined) {
        jsonRecurr.until.adjust(1, 0, 0, 0, 0);
      }
      const { freq } = jsonRecurr;
      if (freq === 'MONTHLY') {
        // If there is a setpos, I need ot merge them up into one param
        // RRule gen splits them into bysetpos and byday, but server takes in byday
        // E.g. bysetpos = 1, byday = TU, merge to byday = 1TU
        // If there is no setpos, it means it is a by month day event
        if (jsonRecurr.BYSETPOS !== undefined) {
          jsonRecurr.BYDAY = jsonRecurr.BYSETPOS + jsonRecurr.BYDAY;
          delete jsonRecurr.BYSETPOS;
        } else if (Array.isArray(jsonRecurr.BYDAY)) {
          jsonRecurr.BYDAY = jsonRecurr.BYDAY.join(',');
        }
      }

      const exDates = [];
      if (recurrencePattern.exDates !== undefined && recurrencePattern.exDates !== null) {
        if (typeof recurrencePattern.exDates === 'number') {
          exDates.push(recurrencePattern.exDates);
        } else {
          exDates.push(
            ...recurrencePattern.exDates
              .split(',')
              .map(str => parseInt(str, 10))
              .filter(exDate =>
                moment
                  .tz(exDate * 1000, data.start.timezone)
                  .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone))
              )
          );
        }
      }

      const recurrenceIds = [];
      if (
        recurrencePattern.recurrenceIds !== undefined &&
        recurrencePattern.recurrenceIds !== null
      ) {
        if (typeof recurrencePattern.recurrenceIds === 'number') {
          recurrenceIds.push(recurrencePattern.recurrenceIds);
        } else {
          recurrenceIds.push(
            ...recurrencePattern.recurrenceIds
              .split(',')
              .map(str => parseInt(str, 10))
              .filter(recurrenceId =>
                moment
                  .tz(recurrenceId * 1000, data.start.timezone)
                  .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone))
              )
          );
        }
      }

      const toBeEditedRp = {
        freq: jsonRecurr.freq,
        interval: jsonRecurr.interval ? jsonRecurr.interval : 1,
        iCALString: payload.rrule,
        isCount: jsonRecurr.until ? false : true,
        exDates: exDates.join(','),
        recurrenceIds: recurrenceIds.join(','),
        ...(jsonRecurr.count && { numberOfRepeats: jsonRecurr.count }),
        ...(jsonRecurr.until && { until: jsonRecurr.until.toUnixTime() }),
      };
      // update specific recurrence pattern via data.iCalUID
      CalendarPluginStore.updateIcloudRpLists(
        toBeEditedRp,
        UPDATE_RECURRENCE_PATTERN,
        data.iCalUID
      );

      // Builds the iCal string
      iCalString = IcalStringBuilder.buildICALStringUpdateAllRecurEvent(jsonRecurr, data, payload);
      if (debug) {
        console.log(iCalString);
      }

      // Due to how there is no master,
      // We need to ensure all events that are part of the series
      // have the same iCal string such that we do not have inconsistency.
      // Run a db query, to update them all to the new iCalString.
      const toBeEditedIcalstring = { iCALString: iCalString };
      Actions.updateIcloudCalendarData(data.iCalUID, toBeEditedIcalstring, UPDATE_ICALSTRING);

      // However, we need to run an update on all the events that are not edited
      // to ensure that all the fields are updated
      // TO-DO, ADD MORE FIELDS HERE

      // #region Delete away all old previous data
      Actions.deleteIcloudCalendarData(data.iCalUID, DELETE_ALL_RECURRING_EVENTS);

      // #region Updating Calendar, Local Side
      // The idea here is using the new iCalString generated, to create the new events to parse in.
      // So we first expand events based off the updated recurrence pattern and master.
      // After that, we append it into the reflux store
      const oldFutureResults = PARSER.parseCalendarData(
        iCalString,
        etag,
        caldavUrl,
        calendarId,
        payload.colorId
      );
      const oldExpanded = PARSER.expandRecurEvents(
        oldFutureResults.map(calEvent => calEvent.eventData)
      );
      const oldFinalResult = [
        ...oldExpanded,
        ...oldFutureResults
          .filter(e => e.recurData === undefined || e.recurData === null)
          .map(e => e.eventData),
      ];
      oldFinalResult.forEach(newEvent => {
        newEvent.owner = user.username;
        newEvent.caldavType = user.caldavType;
      });
      Actions.addIcloudCalendarData(oldFinalResult);
    }
    // #endregion

    // #region Updating Calendar, Server Side
    const calendarObject = {
      url: caldavUrl,
      calendarData: iCalString,
    };
    // Result will throw error, we can do a seperate check here if needed.
    await dav.updateCalendarObject(calendarObject, option);
    // #endregion
  } catch (error) {
    console.log(
      '(editCalDavAllRecurrenceEvents) Error, retrying with pending action!',
      error,
      payload.id
    );
  }
};

export const editCalDavAllFutureRecurrenceEvents = async payload => {
  const debug = false;
  try {
    // #region Getting information
    // Get Information from flux store
    const [data] = CalendarPluginStore.getIcloudCalendarData().filter(
      event => event.id === payload.id
    );
    // no event found
    if (data === undefined) {
      console.log('error');
      return;
    }
    const { user } = payload;
    // #endregion

    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl, calendarId, iCalUID } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag,
    };
    // #endregion

    // #region Recurrence Pattern updating
    const [recurrencePattern] = CalendarPluginStore.getIcloudRpLists().filter(
      rp => rp.originalId === data.iCalUID
    );
    const updatedId = uuidv4();
    const updatedUid = uuidv4();

    const oldRecurringPattern = {};
    const newRecurrencePattern = {};

    const jsonRecurr = ICAL.Recur._stringToData(payload.rrule);
    if (jsonRecurr.until !== undefined) {
      jsonRecurr.until.adjust(1, 0, 0, 0, 0);
    }

    const { freq } = jsonRecurr;
    if (freq === 'MONTHLY') {
      // If there is a setpos, I need ot merge them up into one param
      // RRule gen splits them into bysetpos and byday, but server takes in byday
      // E.g. bysetpos = 1, byday = TU, merge to byday = 1TU
      // If there is no setpos, it means it is a by month day event
      if (jsonRecurr.BYSETPOS !== undefined) {
        jsonRecurr.BYDAY = jsonRecurr.BYSETPOS + jsonRecurr.BYDAY;
        delete jsonRecurr.BYSETPOS;
      } else if (Array.isArray(jsonRecurr.BYDAY)) {
        jsonRecurr.BYDAY = jsonRecurr.BYDAY.join(',');
      }

      // if (Array.isArray(jsonRecurr.BYMONTHDAY)) {
      //   jsonRecurr.BYMONTHDAY = `${jsonRecurr.BYMONTHDAY.join(',')}`;
      // } else if (jsonRecurr.BYMONTHDAY === undefined) {
      //   jsonRecurr.BYMONTHDAY = '';
      // }
    }
    Object.assign(newRecurrencePattern, {
      id: updatedId,
      originalId: updatedUid,
      // // Temp take from the recurrence master first, will take from the UI in future.
      freq: recurrencePattern.freq,
      // interval: pattern.interval,
      interval: payload.recurrInterval,
      until: payload.untilDate,
      exDates: recurrencePattern.exDates
        .split(',')
        .map(str => parseInt(str, 10))
        .filter(exDate =>
          moment
            .tz(exDate * 1000, data.start.timezone)
            .isAfter(moment.tz(data.start.dateTime * 1000, data.start.timezone))
        )
        .join(','),
      recurrenceIds: recurrencePattern.recurrenceIds
        .split(',')
        .map(str => parseInt(str, 10))
        .filter(recurrId =>
          moment
            .tz(recurrId * 1000, data.start.timezone)
            .isAfter(moment.tz(data.start.dateTime * 1000, data.start.timezone))
        )
        .join(','),
      recurringTypeId: data.start.dateTime,
      iCalUID: updatedUid,
      rrule: jsonRecurr,
      byWeekNo: payload.byWeekNo.charAt(1),
      byWeekDay: jsonRecurr.BYDAY !== undefined ? jsonRecurr.BYDAY : '',
      byMonth: jsonRecurr.BYMONTH !== undefined ? jsonRecurr.BYMONTH : '',
      byMonthDay: jsonRecurr.BYMONTHDAY !== undefined ? jsonRecurr.BYMONTHDAY : '',
    });

    if (
      (recurrencePattern.until === undefined || recurrencePattern.until === null) &&
      (recurrencePattern.numberOfRepeats === undefined ||
        recurrencePattern.numberOfRepeats === null)
    ) {
      // No end condition for this, figure out later LOL
    } else if (recurrencePattern.until === undefined || recurrencePattern.until === null) {
      // Parse deleted and edited instances over.
      const exDates = [];
      if (recurrencePattern.exDates !== undefined && recurrencePattern.exDates !== null) {
        if (typeof recurrencePattern.exDates === 'number') {
          exDates.push(recurrencePattern.exDates);
        } else {
          exDates.push(
            ...recurrencePattern.exDates
              .split(',')
              .map(str => parseInt(str, 10))
              .filter(exDate =>
                moment
                  .tz(exDate * 1000, data.start.timezone)
                  .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone))
              )
          );
        }
      }

      const recurrenceIds = [];
      // eslint-disable-next-line prettier/prettier
      if (recurrencePattern.recurrenceIds !== undefined && recurrencePattern.recurrenceIds !== null) {
        if (typeof recurrencePattern.recurrenceIds === 'number') {
          recurrenceIds.push(recurrencePattern.recurrenceIds);
        } else {
          recurrenceIds.push(
            ...recurrencePattern.recurrenceIds
              .split(',')
              .map(str => parseInt(str, 10))
              .filter(recurrenceId =>
                moment
                  .tz(recurrenceId * 1000, data.start.timezone)
                  .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone))
              )
          );
        }
      }
      // The idea here is to first update the old recurrence pattern with until
      // so that we can generate a ruleset as the freq could be a daily/weekly/monthly
      // or have some weird interval.
      // Once we have done that, we filter the exdate and recurrenceids so that the old pattern
      // does not have the extra dates as the series has shortened.
      // As the start date is the same, we set the recurringtypeId as the same.
      // In the future, I need to change the freq and interval based off the UI here.
      // We also need to ensure that the id is the same due to updating of database.
      // Originalid is the caldavUID given by the server.
      Object.assign(oldRecurringPattern, {
        id: recurrencePattern.id,
        originalId: recurrencePattern.originalId,
        freq: recurrencePattern.freq,
        interval: recurrencePattern.interval,
        exDates: exDates.join(','),
        recurrenceIds: recurrenceIds.join(','),
        recurringTypeId: recurrencePattern.recurringTypeId,
        until: moment
          .tz(data.start.dateTime * 1000, data.start.timezone)
          .subtract(1, 'second')
          .unix(),
        isCount: true,
        byMonthDay: payload.byMonthDay,
        byWeekDay: payload.byWeekDay,
        byWeekNo: payload.byWeekNo,
      });

      // We build the ruleset based off the temp pattern, and as we dealing with count,
      // We use the all function to get the length of the input.
      // Parsed into Json for readability and able to be manipulated. RxDocs are not mutable.
      // As we editing this event, we need the minus one.
      const ruleSet = PARSER.buildRuleSet(
        oldRecurringPattern,
        recurrencePattern.recurringTypeId,
        data.start.timezone
      );
      // Recur Dates only hold events and not exceptions.
      const recurDates = ruleSet.all().map(date => date.toJSON());
      // const seriesEndCount = pattern.numberOfRepeats - recurDates.length + 1;
      Object.assign(newRecurrencePattern, {
        numberOfRepeats: payload.untilAfter, // New Rp needs to repeat from that day till the next.
        isCount: true,
      });

      // Delete removes the definition as we want to ensure the UI uses count.
      // It checks via undefined, which deletes makes it.
      delete oldRecurringPattern.until;

      // Reassign the values of old pattern, Safety set the exdates and recurrenceids again.
      Object.assign(oldRecurringPattern, {
        // numberOfRepeats: recurDates.length + oldRecurringPattern.recurrenceIds.length, // Old RP needs to repeat till the selected event minus one.
        numberOfRepeats: recurDates.length - 1,
        isCount: true,
      });

      const toBeEditedRp1 = {
        numberOfRepeats: recurDates.length - 1, // Old RP needs to repeat till the selected event minus one.
        isCount: true,
      };
      // eslint-disable-next-line prettier/prettier
      CalendarPluginStore.updateIcloudRpLists(toBeEditedRp1, UPDATE_RECURRENCE_PATTERN, data.iCalUID)
    } else {
      // Here, we assign the end condition for our recurrence pattern.
      // We set the until, and the UI will take care of the rest.
      Object.assign(newRecurrencePattern, {
        until: recurrencePattern.until,
        isCount: false,
      });

      // Minus one day, and format it, to ensure that the until is properly formatted.
      // Minus one day due to how expanding of event works for caldav.
      const updatedUntil = moment
        .tz(data.start.dateTime * 1000, data.start.timezone)
        .subtract(1, 'second')
        .unix();

      // Parse deleted and edited instances over.
      const exDates = [];
      if (recurrencePattern.exDates !== undefined && recurrencePattern.exDates !== null) {
        if (typeof recurrencePattern.exDates === 'number') {
          exDates.push(recurrencePattern.exDates);
        } else {
          exDates.push(
            ...recurrencePattern.exDates
              .split(',')
              .map(str => parseInt(str, 10))
              .filter(exDate =>
                moment
                  .tz(exDate * 1000, data.start.timezone)
                  .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone))
              )
          );
        }
      }

      const recurrenceIds = [];
      // eslint-disable-next-line prettier/prettier
      if (recurrencePattern.recurrenceIds !== undefined && recurrencePattern.recurrenceIds !== null) {
        if (typeof recurrencePattern.recurrenceIds === 'number') {
          recurrenceIds.push(recurrencePattern.recurrenceIds);
        } else {
          recurrenceIds.push(
            ...recurrencePattern.recurrenceIds
              .split(',')
              .map(str => parseInt(str, 10))
              .filter(recurrenceId =>
                moment
                  .tz(recurrenceId * 1000, data.start.timezone)
                  .isBefore(moment.tz(data.start.dateTime * 1000, data.start.timezone))
              )
          );
        }
      }

      // Update the old pattern to the start date of the selected event.
      // Ensure that the exdate and recurrenceid does not have duplicates.
      const toBeEditedRp2 = {
        until: updatedUntil,
        isCount: false,
        exDates: exDates.join(','),
        recurrenceIds: recurrenceIds.join(','),
      };
      // eslint-disable-next-line prettier/prettier
      CalendarPluginStore.updateIcloudRpLists(toBeEditedRp2, UPDATE_RECURRENCE_PATTERN, data.iCalUID);
    }
    // Debug, also meant for generating the new icalstring based off the recurrence pattern.
    // const updatedOldRecurPattern = await recurPatternQuery.exec();
    const [updatedOldPattern] = CalendarPluginStore.getIcloudRpLists().filter(
      rp => rp.originalId === data.iCalUID
    );
    // Builds the old iCal string, which has edited based off the recurring pattern.
    const oldiCalString = IcalStringBuilder.buildICALStringUpdateFutureRecurMasterEvent(
      updatedOldPattern,
      data,
      payload
    );
    // Builds the new iCal string, which has been created based off the recurring pattern.
    const newiCalString = IcalStringBuilder.buildICALStringUpdateFutureRecurCreateEvent(
      newRecurrencePattern,
      data,
      payload
    );
    // insert the new recurrence pattern into database, as it is new, should not have any issues.
    CalendarPluginStore.updateIcloudRpLists(newRecurrencePattern, UPSERT_RECURRENCE_PATTERN);

    // Update the old recurrence pattern with the new iCalString.
    const toBeEditedCalstring = { iCALString: updatedOldPattern.iCALString };
    // eslint-disable-next-line prettier/prettier
    CalendarPluginStore.updateIcloudRpLists(toBeEditedCalstring, UPDATE_RECURRENCE_PATTERN, data.iCalUID);
    // #endregion

    // #region Updating Calendar, Server Side
    const updateCalendarObject = {
      url: caldavUrl,
      calendarData: newiCalString,
    };
    // Result will throw error, we can do a seperate check here if needed.
    const updateResult = await dav.updateCalendarObject(updateCalendarObject, option);
    if (debug) {
      console.log(updateResult);
    }
    // #endregion

    // #region Adding Future Events, Server Side
    const calendar = new dav.Calendar();
    calendar.url = caldavUrl;

    const newETag = uuidv4();
    if (debug) {
      console.log(caldavUrl, newETag, etag);
    }
    const addCalendarObject = {
      data: oldiCalString,
      filename: `${newETag}.ics`,
      xhr: xhrObject,
    };

    // TODO: create only when the selected event is not the first in the series
    const oldCalendarData = ICAL.parse(oldiCalString);
    const oldvcalendar = new ICAL.Component(oldCalendarData);
    const newCalendarData = ICAL.parse(newiCalString);
    const newvcalendar = new ICAL.Component(newCalendarData);
    // eslint-disable-next-line no-underscore-dangle
    const oldDate = oldvcalendar.getAllSubcomponents('vevent')[0].getFirstPropertyValue('dtstart')
      ._time;
    // eslint-disable-next-line no-underscore-dangle
    const newDate = newvcalendar.getAllSubcomponents('vevent')[0].getFirstPropertyValue('dtstart')
      ._time;

    if (
      oldDate.day !== newDate.day ||
      oldDate.month !== newDate.month ||
      oldDate.year !== newDate.year
    ) {
      const addResult = await dav.createCalendarObject(calendar, addCalendarObject);
      if (debug) {
        console.log(addResult);
      }
    }

    // #endregion

    // #region Delete away all old previous data
    Actions.deleteIcloudCalendarData(iCalUID, DELETE_ALL_RECURRING_EVENTS);
    // #endregion

    // #region Updating Calendar, Local Side
    // The idea here is using the old iCalString generated, to create the new events to parse in.
    // So we first expand events based off the updated recurrence pattern and master.
    // After that, we append it into the reflux store
    const oldFutureResults = PARSER.parseCalendarData(oldiCalString, etag, caldavUrl, calendarId);
    const oldExpanded = await PARSER.expandRecurEvents(
      oldFutureResults.map(calEvent => calEvent.eventData)
    );
    const oldFinalResult = [
      ...oldExpanded,
      ...oldFutureResults
        .filter(e => e.recurData === undefined || e.recurData === null)
        .map(e => e.eventData),
    ];
    oldFinalResult.forEach(newEvent => {
      newEvent.owner = user.username;
      newEvent.caldavType = user.caldavType;
    });
    Actions.addIcloudCalendarData(oldFinalResult);
    // #endregion

    const newFutureResults = PARSER.parseCalendarData(
      newiCalString,
      newETag,
      caldavUrl,
      calendarId
    );
    const newExpanded = await PARSER.expandRecurEvents(
      newFutureResults.map(calEvent => calEvent.eventData)
    );
    const newFinalResult = [
      ...newExpanded,
      ...newFutureResults
        .filter(e => e.recurData === undefined || e.recurData === null)
        .map(e => e.eventData),
    ];

    newFinalResult.forEach(event => (event.owner = user.username));
    Actions.addIcloudCalendarData(newFinalResult);
  } catch (error) {
    console.log(
      '(editCalDavFutureRecurrenceEventEpics) Error, retrying with pending action!',
      error,
      payload.id
    );
  }
};
