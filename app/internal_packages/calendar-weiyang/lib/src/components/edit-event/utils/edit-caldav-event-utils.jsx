import ICAL from 'ical.js';
import uuidv4 from 'uuid';
import moment from 'moment-timezone';
import * as IcalStringBuilder from '../../common-utils/ical-string-builder';
import * as PARSER from '../../common-utils/parser';
import { Actions, CalendarPluginStore } from 'mailspring-exports';
import { deleteCaldavFuture } from '../../delete-event/delete-caldav-event-utils';
import {
  DELETE_ALL_RECURRING_EVENTS,
  DELETE_FUTURE_RECCURRING_EVENTS,
  DELETE_NON_MASTER_EVENTS,
  UPDATE_ICALSTRING,
  UPDATE_MASTER_EVENT,
  UPDATE_RECURRENCE_PATTERN,
  UPDATE_SINGLE_EVENT,
  UPSERT_RECURRENCE_PATTERN,
} from '../../constants';
import { createCaldavEvent } from '../../create-event/utils/create-caldav-event-utils';
const dav = require('dav');

export const editCaldavSingle = async payload => {
  const debug = false;
  try {
    let iCalString;

    // #region Getting information
    // Get Information from flux store
    const [data] = CalendarPluginStore.getIcloudCalendarData().filter(
      event => event.id === payload.id
    );
    // no event found
    if (data === undefined) {
      console.log('error');
      return;
    }
    const { user } = payload;
    // #endregion

    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    console.log('data', data);
    const { etag, caldavUrl } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag,
    };
    // #endregion

    const updatedRruleObj = ICAL.Recur._stringToData(payload.updatedRrule);
    const { freq } = updatedRruleObj;
    if (freq === 'MONTHLY') {
      // If there is a setpos, I need to merge them up into one param
      // RRule gen splits them into bysetpos and byday, but server takes in byday
      // E.g. bysetpos = 1, byday = TU, merge to byday = 1TU
      // If there is no setpos, it means it is a by month day event
      if (updatedRruleObj.BYSETPOS !== undefined) {
        updatedRruleObj.BYDAY = updatedRruleObj.BYSETPOS + updatedRruleObj.BYDAY;
        delete updatedRruleObj.BYSETPOS;
      } else if (Array.isArray(updatedRruleObj.BYDAY)) {
        updatedRruleObj.BYDAY = updatedRruleObj.BYDAY.join(',');
      }
    }
    const updatedRruleString = ICAL.Recur.fromData(updatedRruleObj).toString();
    // #region Updating of Single event, based on Recurring or not
    if (payload.isRecurring) {
      const [recurrencePattern] = CalendarPluginStore.getIcloudRpLists().filter(
        rp => data.iCalUID === rp.iCalUID
      );
      if (recurrencePattern === undefined) {
        console.log('error');
        return;
      }
      // Builds the iCal string, adding/updating vevent
      iCalString = IcalStringBuilder.buildICALStringUpdateRecurEvent(
        recurrencePattern,
        data,
        payload
      );
      // Due to how there is no master,
      // We need to ensure all events that are part of the series
      // have the same iCal string such that we do not have inconsistency.
      // Update them all to the new iCalString.
      const toBeEditedIcalstring = { iCALString: iCalString };
      Actions.updateIcloudCalendarData(data.iCalUID, toBeEditedIcalstring, UPDATE_ICALSTRING);
    } else if (!payload.isRecurring && payload.updatedIsRecurring) {
      // if event is originally single and is going to become recurring, change entire vevent
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleAndAllEvent(
        payload,
        data,
        updatedRruleObj
      );
    } else {
      // single, non-recurring event, change entire vevent
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleAndAllEvent(payload, data);
    }
    // #endregion

    // #region Updating Calendar, Local Side
    // single -> recurring event
    if (!payload.isRecurring && payload.updatedIsRecurring) {
      // expanding events to be added into store
      const masterEvent = data; // data = event object retrieved from db
      masterEvent.isRecurring = 1;
      masterEvent.isMaster = 1;
      masterEvent.iCALString = iCalString;
      masterEvent.allDay = payload.allDay;
      masterEvent.attendee = JSON.stringify(payload.attendee);
      masterEvent.description = payload.description;
      masterEvent.end = {
        dateTime: payload.end.unix(),
        timezone: payload.end.tz(),
      };
      masterEvent.start = {
        dateTime: payload.start.unix(),
        timezone: payload.start.tz(),
      };
      masterEvent.location = payload.location;
      masterEvent.summary = payload.title;
      let untilJson;
      if (updatedRruleObj.until !== undefined) {
        untilJson = updatedRruleObj.until.toJSON();
        untilJson.month -= 1; // Month needs to minus one due to start date
      }
      console.log('untiljson', untilJson);
      console.log('untiljson moment', moment.tz(untilJson, 'UTC').unix());
      console.log('masterevent', masterEvent);
      console.log('payload', payload);
      const recurrencePattern = PARSER.parseRecurrenceEvents([
        {
          eventData: masterEvent,
          recurData: {
            rrule: {
              stringFormat: updatedRruleString,
              freq: updatedRruleObj.freq,
              interval: updatedRruleObj.interval !== undefined ? updatedRruleObj.interval : 1,
              until: moment.tz(untilJson, 'UTC').unix() * 1000,
              count: updatedRruleObj.count,
            },
            exDates: [],
            recurrenceIds: [],
            modifiedThenDeleted: false,
            iCALString: updatedRruleString,
          },
        },
      ]);
      console.log('recur pattern', recurrencePattern);
      const expandedRecurEvents = PARSER.parseRecurrence(recurrencePattern[0], masterEvent);
      CalendarPluginStore.updateIcloudRpLists(recurrencePattern[0], UPSERT_RECURRENCE_PATTERN);
      console.log('expanded', expandedRecurEvents);
      // add expanded events into reflux
      Actions.addIcloudCalendarData(expandedRecurEvents);
    } else {
      // update single edited event via reflux
      const toBeEditedEvent = {
        summary: payload.title,
        description: payload.description,
        start: { dateTime: payload.start.unix(), timezone: payload.start.tz() },
        end: { dateTime: payload.end.unix(), timezone: payload.end.tz() },
        allDay: payload.allDay,
        location: payload.location,
        attendee: JSON.stringify(payload.attendee),
      };
      Actions.updateIcloudCalendarData(payload.id, toBeEditedEvent, UPDATE_SINGLE_EVENT);
    }
    // #endregion

    // #region Updating Calendar, Server Side
    const calendarObject = {
      url: caldavUrl,
      calendarData: iCalString,
    };
    // Result will throw error, we can do a seperate check here if needed.
    console.log('calendarobj', calendarObject);
    await dav.updateCalendarObject(calendarObject, option).then(result => console.log(result));
    // #endregion
  } catch (error) {
    console.log('(editCalDavSingle) Error', error, payload.id);
  }
};

export const editCaldavAll = async payload => {
  const debug = false;
  try {
    // #region Getting information
    // Get Information from flux store
    const [data] = CalendarPluginStore.getIcloudCalendarData().filter(
      event => event.id === payload.id
    );
    // no event found
    if (data === undefined) {
      console.log('error');
      return;
    }
    const { user } = payload;
    // #endregion
    const updatedRruleObj = ICAL.Recur._stringToData(payload.updatedRrule);
    const { freq } = updatedRruleObj;
    if (freq === 'MONTHLY') {
      // If there is a setpos, I need to merge them up into one param
      // RRule gen splits them into bysetpos and byday, but server takes in byday
      // E.g. bysetpos = 1, byday = TU, merge to byday = 1TU
      // If there is no setpos, it means it is a by month day event
      if (updatedRruleObj.BYSETPOS !== undefined) {
        updatedRruleObj.BYDAY = updatedRruleObj.BYSETPOS + updatedRruleObj.BYDAY;
        delete updatedRruleObj.BYSETPOS;
      } else if (Array.isArray(updatedRruleObj.BYDAY)) {
        updatedRruleObj.BYDAY = updatedRruleObj.BYDAY.join(',');
      }
    }
    const updatedRruleString = ICAL.Recur.fromData(updatedRruleObj).toString();
    // #region CalDav sending details
    // Needed information for deleting of Caldav information.
    // etag - Event tag, there is the same for calendar if needed.
    //   UUID generated by caldav servers
    // caldavUrl - URL of specific endpoint for deleting single or recurrring events
    const { etag, caldavUrl, calendarId } = data;

    // Parse user information from account layer to dav object.
    const xhrObject = new dav.transport.Basic(
      new dav.Credentials({
        username: user.username,
        password: user.password,
      })
    );
    // Ensure etag is set in option for no 412 http error.
    const option = {
      xhr: xhrObject,
      etag,
    };
    // #endregion

    // #region Generation of new iCalString & store updating
    // For recurring events, we want to just add it to ex dates instead
    // Due to caldav nature, deleting an etag instead of updating results in deleting of
    // entire series.
    // Updating is done by pushing the entire iCal string to the server
    let iCalString = '';
    // retrieve master event
    const [masterEvent] = CalendarPluginStore.getIcloudCalendarData().filter(
      event => event.isMaster && event.recurringEventId === data.recurringEventId
    );
    // delete non-master
    Actions.deleteIcloudCalendarData(data.recurringEventId, DELETE_NON_MASTER_EVENTS);
    // delete recurrencePattern
    CalendarPluginStore.deleteIcloudRpLists(data.iCalUID);
    if (!payload.updatedIsRecurring) {
      // recur -> single

      // update iCal string
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleAndAllEvent(payload, masterEvent);

      // update store
      const toBeEditedData = {
        summary: payload.title,
        description: payload.description,
        allDay: payload.allDay,
        start: { dateTime: payload.start.unix(), timezone: payload.start.tz() },
        end: { dateTime: payload.end.unix(), timezone: payload.end.tz() },
        location: payload.location,
        organizer: payload.organizer,
        attendee: payload.attendees,
        recurringEventId: null,
        isRecurring: false,
        iCALString: iCalString,
      };
      // update master event
      Actions.updateIcloudCalendarData(masterEvent.id, toBeEditedData, UPDATE_MASTER_EVENT);
    } else {
      // old recur -> new recur

      // update ical string
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleAndAllEvent(
        payload,
        data,
        updatedRruleObj
      );

      // expanding events into store
      masterEvent.iCALString = iCalString;
      masterEvent.allDay = payload.allDay;
      masterEvent.attendee = JSON.stringify(payload.attendee);
      masterEvent.description = payload.description;
      masterEvent.end = {
        dateTime: payload.end.unix(),
        timezone: payload.end.tz(),
      };
      masterEvent.start = {
        dateTime: payload.start.unix(),
        timezone: payload.start.tz(),
      };
      masterEvent.location = payload.location;
      masterEvent.summary = payload.title;
      let untilJson;
      if (updatedRruleObj.until !== undefined) {
        untilJson = updatedRruleObj.until.toJSON();
        untilJson.month -= 1; // Month needs to minus one due to start date
      }
      const recurrencePattern = PARSER.parseRecurrenceEvents([
        {
          eventData: masterEvent,
          recurData: {
            rrule: {
              stringFormat: updatedRruleString,
              freq: updatedRruleObj.freq,
              interval: updatedRruleObj.interval !== undefined ? updatedRruleObj.interval : 1,
              until: untilJson,
              count: updatedRruleObj.count,
            },
            exDates: [],
            recurrenceIds: [],
            modifiedThenDeleted: false,
            iCALString: updatedRruleString,
          },
        },
      ]);
      const expandedRecurEvents = PARSER.parseRecurrence(recurrencePattern[0], masterEvent);
      Actions.addIcloudCalendarData(expandedRecurEvents);

      // add new rp into store
      CalendarPluginStore.updateIcloudRpLists(recurrencePattern[0], UPSERT_RECURRENCE_PATTERN);
    }
    // #endregion
    // #region Updating Calendar, Server Side
    const calendarObject = {
      url: caldavUrl,
      calendarData: iCalString,
    };
    // Result will throw error, we can do a seperate check here if needed.
    await dav.updateCalendarObject(calendarObject, option);
    // #endregion
  } catch (error) {
    console.log(
      '(editCalDavAllRecurrenceEvents) Error, retrying with pending action!',
      error,
      payload.id
    );
  }
};

export const editCaldavFuture = async payload => {
  // 1) delete future events by limiting UNTIL of original calendar object
  // 2) add new calendar object with updated RRule
  // this means 1 calendar object is splitted into 2 calendar object each with their own RRule
  // the edited events are no longer in the same recurrence series
  // #region Getting information
  // Get Information from flux store
  const [data] = CalendarPluginStore.getIcloudCalendarData().filter(
    event => event.id === payload.id
  );
  console.log('data', data);
  // no event found
  if (data === undefined) {
    console.log('error');
    return;
  }
  const { user } = payload;
  try {
    const deleteFuturePayload = {
      data,
      user,
    };
    await deleteCaldavFuture(deleteFuturePayload);
    Actions.deleteIcloudCalendarData(
      data.iCalUID,
      DELETE_FUTURE_RECCURRING_EVENTS,
      data.start.dateTime
    );
  } catch (error) {
    console.log('delete failed while editing future recurrence', error);
  }

  try {
    const [selectedCalendar] = CalendarPluginStore.getIcloudCalendarLists().filter(
      calendar => calendar.url === data.calendarId
    );
    const createFutureEventData = {
      summary: payload.title,
      description: payload.description,
      start: {
        dateTime: payload.start,
        timezone: payload.tzid,
      },
      end: {
        dateTime: payload.end,
        timezone: payload.tzid,
      },
      isRecurring: payload.isRecurring,
      rrule: payload.rrule,
      allDay: payload.allDay,
      colorId: data.colorId,
      location: payload.location,
      attendee: payload.attendee,
      organizer: payload.organizer,
      calendarId: data.calendarId,
    };
    const createFutureEventPayload = {
      data: createFutureEventData,
      providerType: payload.providerType,
      auth: user,
      calendar: selectedCalendar,
    };
    await createCaldavEvent(createFutureEventPayload);
  } catch (error) {
    console.log('error creating new recurrence while editing future', error);
  }
};
