import ICAL from 'ical.js';
import uuidv4 from 'uuid';
import moment from 'moment-timezone';
import * as IcalStringBuilder from '../../common-utils/ical-string-builder';
import * as PARSER from '../../common-utils/parser';
import { Actions, CalendarPluginStore } from 'mailspring-exports';
import { deleteCaldavAll, deleteCaldavFuture } from '../../delete-event/delete-caldav-event-utils';
import {
  DELETE_ALL_RECURRING_EVENTS,
  DELETE_FUTURE_RECCURRING_EVENTS,
  DELETE_NON_MASTER_EVENTS,
  ICLOUD_ACCOUNT,
  UPDATE_ICALSTRING,
  UPDATE_MASTER_EVENT,
  UPDATE_RECURRENCE_PATTERN,
  UPDATE_SINGLE_EVENT,
  UPSERT_RECURRENCE_PATTERN,
} from '../../constants';
import { createCaldavEvent } from '../../create-event/utils/create-caldav-event-utils';
const dav = require('dav');

export const editCaldavSingle = async payload => {
  const debug = false;
  let iCalString;

  // #region Getting information
  // Get Information from flux store
  const [data] = CalendarPluginStore.getCalendarData(ICLOUD_ACCOUNT).filter(
    event => event.id === payload.id
  );
  // no event found
  if (data === undefined) {
    console.log('error');
    return;
  }
  const { user } = payload;
  // #endregion

  // #region CalDav sending details
  // Needed information for deleting of Caldav information.
  // etag - Event tag, there is the same for calendar if needed.
  //   UUID generated by caldav servers
  // caldavUrl - URL of specific endpoint for deleting single or recurrring events
  const { etag, caldavUrl } = data;

  // Parse user information from account layer to dav object.
  const xhrObject = new dav.transport.Basic(
    new dav.Credentials({
      username: user.username,
      password: user.password,
    })
  );
  // Ensure etag is set in option for no 412 http error.
  const option = {
    xhr: xhrObject,
    etag,
  };
  // #endregion

  const updatedRruleObj = ICAL.Recur._stringToData(payload.updatedRrule);
  const { freq } = updatedRruleObj;
  if (freq === 'MONTHLY') {
    // If there is a setpos, I need to merge them up into one param
    // RRule gen splits them into bysetpos and byday, but server takes in byday
    // E.g. bysetpos = 1, byday = TU, merge to byday = 1TU
    // If there is no setpos, it means it is a by month day event
    if (updatedRruleObj.BYSETPOS !== undefined) {
      updatedRruleObj.BYDAY = updatedRruleObj.BYSETPOS + updatedRruleObj.BYDAY;
      delete updatedRruleObj.BYSETPOS;
    } else if (Array.isArray(updatedRruleObj.BYDAY)) {
      updatedRruleObj.BYDAY = updatedRruleObj.BYDAY.join(',');
    }
  }
  const updatedRruleString = ICAL.Recur.fromData(updatedRruleObj).toString();
  // #region Updating of Single event, based on Recurring or not
  if (payload.isRecurring) {
    try {
      const [recurrencePattern] = CalendarPluginStore.getRpLists(ICLOUD_ACCOUNT).filter(
        rp => data.iCalUID === rp.iCalUID
      );
      if (recurrencePattern === undefined) {
        throw 'recurrence pattern cannot be found';
      }
      // Builds the iCal string, adding/updating vevent
      iCalString = IcalStringBuilder.buildICALStringUpdateRecurEvent(
        recurrencePattern,
        data,
        payload
      );
      const calendarObject = {
        url: caldavUrl,
        calendarData: iCalString,
      };
      await dav.updateCalendarObject(calendarObject, option);
      // Update them all to the new iCalString.
      const toBeEditedIcalstring = { iCALString: iCalString };
      Actions.updateCalendarData(ICLOUD_ACCOUNT, data.iCalUID, toBeEditedIcalstring, UPDATE_ICALSTRING);
      // update single edited event via reflux
      const toBeEditedEvent = {
        summary: payload.title,
        description: payload.description,
        start: { dateTime: payload.start.unix(), timezone: payload.start.tz() },
        end: { dateTime: payload.end.unix(), timezone: payload.end.tz() },
        isAllDay: payload.isAllDay,
        location: payload.location,
        attendee: JSON.stringify(payload.attendee),
      };
      Actions.updateCalendarData(ICLOUD_ACCOUNT, payload.id, toBeEditedEvent, UPDATE_SINGLE_EVENT);
    } catch (error) {
      console.log('error updating single event from recurring series', error);
    }
  } else if (!payload.isRecurring && payload.updatedIsRecurring) {
    try {
      // if event is originally single and is going to become recurring, change entire vevent
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleAndAllEvent(
        payload,
        data,
        updatedRruleObj
      );
      const calendarObject = {
        url: caldavUrl,
        calendarData: iCalString,
      };
      await dav.updateCalendarObject(calendarObject, option);

      // expanding events to be added into store
      const masterEvent = data; // data = event object retrieved from db
      masterEvent.isRecurring = 1;
      masterEvent.isMaster = 1;
      masterEvent.iCALString = iCalString;
      masterEvent.isAllDay = payload.isAllDay;
      masterEvent.attendee = JSON.stringify(payload.attendee);
      masterEvent.description = payload.description;
      masterEvent.end = {
        dateTime: payload.end.unix(),
        timezone: payload.end.tz(),
      };
      masterEvent.start = {
        dateTime: payload.start.unix(),
        timezone: payload.start.tz(),
      };
      masterEvent.location = payload.location;
      masterEvent.summary = payload.title;
      let untilJson;
      if (updatedRruleObj.until !== undefined) {
        untilJson = updatedRruleObj.until.toJSON();
        untilJson.month -= 1; // Month needs to minus one due to start date
      }
      const recurrencePattern = PARSER.parseRecurrenceEvents([
        {
          eventData: masterEvent,
          recurData: {
            rrule: {
              stringFormat: updatedRruleString,
              freq: updatedRruleObj.freq,
              interval: updatedRruleObj.interval !== undefined ? updatedRruleObj.interval : 1,
              until: moment.tz(untilJson, 'UTC').unix() * 1000,
              count: updatedRruleObj.count,
            },
            exDates: [],
            recurrenceIds: [],
            modifiedThenDeleted: false,
            iCALString: updatedRruleString,
          },
        },
      ]);
      const expandedRecurEvents = PARSER.parseRecurrence(recurrencePattern[0], masterEvent);
      CalendarPluginStore.upsertRpList(recurrencePattern[0]);

      // add all expanded events into reflux and remove any existing similar icaluid from reflux store
      Actions.deleteCalendarData(ICLOUD_ACCOUNT, expandedRecurEvents[0].iCalUID, DELETE_ALL_RECURRING_EVENTS);
      Actions.addCalendarData(expandedRecurEvents, ICLOUD_ACCOUNT);
    } catch (error) {
      console.log('error updating single event to recurring event', error);
    }
  } else {
    try {
      // single, non-recurring event, change entire vevent
      iCalString = IcalStringBuilder.buildICALStringUpdateSingleAndAllEvent(payload, data);
      const calendarObject = {
        url: caldavUrl,
        calendarData: iCalString,
      };
      await dav.updateCalendarObject(calendarObject, option).then(result => console.log(result));
      const toBeEditedEvent = {
        summary: payload.title,
        description: payload.description,
        start: { dateTime: payload.start.unix(), timezone: payload.start.tz() },
        end: { dateTime: payload.end.unix(), timezone: payload.end.tz() },
        isAllDay: payload.isAllDay,
        location: payload.location,
        attendee: JSON.stringify(payload.attendee),
      };
      Actions.updateCalendarData(ICLOUD_ACCOUNT, payload.id, toBeEditedEvent, UPDATE_SINGLE_EVENT);
    } catch (error) {
      console.log('error updating single event from single series', error);
    }
  }
};

export const editCaldavAll = async payload => {
  // 1) delete original event/s
  // 2) add new calendar object with updated RRule
  // #region Getting information
  // Get Information from flux store

  const [data] = CalendarPluginStore.getCalendarData(ICLOUD_ACCOUNT).filter(
    event => event.id === payload.id
  );
  // no event found
  if (data === undefined) {
    console.log('error');
    return;
  }
  const { user } = payload;
  try {
    const deleteAllPayload = {
      data,
      user,
    };
    await deleteCaldavAll(deleteAllPayload);
    Actions.deleteCalendarData(ICLOUD_ACCOUNT, data.iCalUID, DELETE_ALL_RECURRING_EVENTS);
  } catch (error) {
    console.log('delete failed while editing all recurrence', error);
  }

  try {
    const [selectedCalendar] = CalendarPluginStore.getCalendarLists(ICLOUD_ACCOUNT).filter(
      calendar => calendar.url === data.calendarId
    );
    const createFutureEventData = {
      summary: payload.title,
      description: payload.description,
      start: {
        dateTime: payload.start,
        timezone: payload.tzid,
      },
      end: {
        dateTime: payload.end,
        timezone: payload.tzid,
      },
      isRecurring: payload.isRecurring,
      rrule: payload.updatedRrule,
      isAllDay: payload.isAllDay,
      colorId: data.colorId,
      location: payload.location,
      attendee: payload.attendee,
      organizer: payload.organizer,
      calendarId: data.calendarId,
    };
    const createAllEventPayload = {
      data: createFutureEventData,
      providerType: payload.providerType,
      auth: user,
      calendar: selectedCalendar,
    };
    await createCaldavEvent(createAllEventPayload);
  } catch (error) {
    console.log('error creating new recurrence while editing all', error);
  }
};

export const editCaldavFuture = async payload => {
  // 1) delete future events by limiting UNTIL of original calendar object
  // 2) add new calendar object with updated RRule
  // this means 1 calendar object is splitted into 2 calendar object each with their own RRule
  // the edited events are no longer in the same recurrence series
  // #region Getting information
  // Get Information from flux store
  const [data] = CalendarPluginStore.getCalendarData(ICLOUD_ACCOUNT).filter(
    event => event.id === payload.id
  );
  // no event found
  if (data === undefined) {
    console.log('error');
    return;
  }
  const { user } = payload;
  try {
    const deleteFuturePayload = {
      data,
      user,
    };
    await deleteCaldavFuture(deleteFuturePayload);
    Actions.deleteCalendarData(
      ICLOUD_ACCOUNT,
      data.iCalUID,
      DELETE_FUTURE_RECCURRING_EVENTS,
      data.start.dateTime
    );
  } catch (error) {
    console.log('delete failed while editing future recurrence', error);
  }

  try {
    const [selectedCalendar] = CalendarPluginStore.getCalendarLists(ICLOUD_ACCOUNT).filter(
      calendar => calendar.url === data.calendarId
    );
    const createFutureEventData = {
      summary: payload.title,
      description: payload.description,
      start: {
        dateTime: payload.start,
        timezone: payload.tzid,
      },
      end: {
        dateTime: payload.end,
        timezone: payload.tzid,
      },
      isRecurring: payload.isRecurring,
      rrule: payload.rrule,
      isAllDay: payload.isAllDay,
      colorId: data.colorId,
      location: payload.location,
      attendee: payload.attendee,
      organizer: payload.organizer,
      calendarId: data.calendarId,
    };
    const createFutureEventPayload = {
      data: createFutureEventData,
      providerType: payload.providerType,
      auth: user,
      calendar: selectedCalendar,
    };
    await createCaldavEvent(createFutureEventPayload);
  } catch (error) {
    console.log('error creating new recurrence while editing future', error);
  }
};
